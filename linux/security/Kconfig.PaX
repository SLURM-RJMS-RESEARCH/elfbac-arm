menu "PaX"

config PAX
	bool "Enable various PaX features"
	depends on ARM && (CPU_V6 || CPU_V6K || CPU_V7)
	help
	  This allows you to enable various PaX features.  PaX adds
	  intrusion prevention mechanisms to the kernel that reduce
	  the risks posed by exploitable memory corruption bugs.

menu "PaX Control"
	depends on PAX

config PAX_XATTR_PAX_FLAGS
	bool 'Use filesystem extended attributes marking'
	select CIFS_XATTR if CIFS
	select EXT2_FS_XATTR if EXT2_FS
	select EXT3_FS_XATTR if EXT3_FS
	select F2FS_FS_XATTR if F2FS_FS
	select JFFS2_FS_XATTR if JFFS2_FS
	select REISERFS_FS_XATTR if REISERFS_FS
	select SQUASHFS_XATTR if SQUASHFS
	select TMPFS_XATTR if TMPFS
	help
	  Enabling this option will allow you to control PaX features on
	  a per executable basis via the 'setfattr' utility.  The control
	  flags will be read from the user.pax.flags extended attribute of
	  the file.  This marking has the benefit of supporting binary-only
	  applications that self-check themselves (e.g., skype) and would
	  not tolerate chpax/paxctl changes.  The main drawback is that
	  extended attributes are not supported by some filesystems (e.g.,
	  isofs, udf, vfat) so copying files through such filesystems will
	  lose the extended attributes and these PaX markings.

	  If this option is set to 'N' then all applications
	  will run with PaX enabled on them by default.

endmenu

menu "Non-executable pages"
	depends on PAX

config PAX_PAGEEXEC
	bool "Paging based non-executable pages"
	help
	  This implementation is based on the paging feature of the CPU.
	  On ARM with hardware XN support there is no performance
	  impact.

config PAX_MPROTECT
	bool "Restrict mprotect()"
	depends on PAX_PAGEEXEC
	help
	  Enabling this option will prevent programs from
	   - changing the executable status of memory pages that were
	     not originally created as executable,
	   - making read-only executable pages writable again,
	   - creating executable pages from anonymous memory,
	   - making read-only-after-relocations (RELRO) data pages writable again.

	  You should say Y here to complete the protection provided by
	  the enforcement of non-executable pages.

	  NOTE: you can use extended attributes to control this feature on a
	  per file basis.

config PAX_ASLR
	bool "Address Space Layout Randomization"
	help
	  Many if not most exploit techniques rely on the knowledge of
	  certain addresses in the attacked program.  The following options
	  will allow the kernel to apply a certain amount of randomization
	  to specific parts of the program thereby forcing an attacker to
	  guess them in most cases.  Any failed guess will most likely crash
	  the attacked program which allows the kernel to detect such attempts
	  and react on them.  PaX itself provides no reaction mechanisms,
	  instead it is strongly encouraged that you make use of grsecurity's
	  (http://www.grsecurity.net/) built-in crash detection features or
	  develop one yourself.

	  By saying Y here you can choose to randomize the following areas:
	   - top of the task's kernel stack
	   - top of the task's userland stack
	   - base address for mmap() requests that do not specify one
	     (this includes all libraries)
	   - base address of the main executable

	  It is strongly recommended to say Y here as address space layout
	  randomization has negligible impact on performance yet it provides
	  a very effective protection.

	  NOTE: you can use extended attributes to control this feature on a
	  per file basis.

config PAX_RANDUSTACK
	bool

config PAX_RANDMMAP
	bool "Randomize user stack and mmap() bases"
	depends on PAX_ASLR
	select PAX_RANDUSTACK
	help
	  By saying Y here the kernel will randomize every task's userland
	  stack and use a randomized base address for mmap() requests that
	  do not specify one themselves.

	  The stack randomization is done in two steps where the second
	  one may apply a big amount of shift to the top of the stack and
	  cause problems for programs that want to use lots of memory (more
	  than 2.5 GB).

	  As a result of mmap randomization all dynamically loaded libraries
	  will appear at random addresses and therefore be harder to exploit
	  by a technique where an attacker attempts to execute library code
	  for his purposes (e.g. spawn a shell from an exploited program that
	  is running at an elevated privilege level).

	  Furthermore, if a program is relinked as a dynamic ELF file, its
	  base address will be randomized as well, completing the full
	  randomization of the address space layout.  On modern Linux systems,
	  this is achieved through the compilation of PIE binaries.

	  NOTE: you can use extended attributes to control this feature on a
	  per file basis.

endmenu

menu "Miscellaneous hardening features"
	depends on PAX

config PAX_USERCOPY
	bool "Harden heap object copies between kernel and userland"
	depends on ARM && (SLAB || SLUB)
	help
	  By saying Y here the kernel will enforce the size of heap objects
	  when they are copied in either direction between the kernel and
	  userland, even if only a part of the heap object is copied.

	  Specifically, this checking prevents information leaking from the
	  kernel heap during kernel to userland copies (if the kernel heap
	  object is otherwise fully initialized) and prevents kernel heap
	  overflows during userland to kernel copies.

	  Note that the current implementation provides the strictest bounds
	  checks for the SLUB allocator.

	  Enabling this option also enables per-slab cache protection against
	  data in a given cache being copied into/out of via userland
	  accessors.  Though the whitelist of regions will be reduced over
	  time, it notably protects important data structures like task structs.

endmenu

endmenu
