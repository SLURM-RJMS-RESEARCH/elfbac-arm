# elfbac-ld

A wrapper over the GNU linker for generating and inserting ELFbac policies into
ELF binaries.

## Usage

```
usage: elfbac-ld.py [-h] -p POLICY [-l LINKER] [-c] ...

Link a JSON ELFbac policy into a program

positional arguments:
  LINKER ARGS

optional arguments:
  -h, --help            show this help message and exit
  -a ARCH, --arch ARCH  The target architecture for linker script generation,
                        default is elf32-littlearm
  -p POLICY, --policy POLICY
                        The JSON ELFbac policy to link into a program
  -l LINKER, --linker LINKER
                        The linker to invoke to link the program
  -c, --use-compiler    If specified, using the C compiler driver to link the
                        program, so modify altered arguments appropriately
```

## Policy Format

Policies are described by JSON files containing definitions for the possible
ELFbac states, call transitions and data transitions.

State definitions consist of a name, stack identifier, and sections. The name
is used to refer to this state from a transition. The stack identifier specifies
which stack to switch to when entering this state. Section descriptors describe
which areas of the program's memory space can be accessed with what permissions
in a given state.

Sections are defined with a description, flags denoting access restrictions, and
an optional create flag for specifying if the definition of the section should
be inserted into the generated linker script or if the section is pre-defined by
the existing linker script, and defaults to true. Descriptions should match the
syntax used for describing an input section in a GNU linker linker script,
please refer to section 4.6.4 Input Section Description in the GNU linker manual
for more information.

Call transitions are defined by a from and to state (state names as defined in
the states list), address trigering the transition, size of all function
parameters and the size of the returned value.

Data transitions are defined by a from and to state (state names as defined in
the states list), flags denoting access restrictions, base address, and size.

Please refer to the example policy JSON file for the exact structure required by
the tool.

## Under the Hood

This tool will parse policy JSON files and generate a linker script and binary
policy description in order to create a binary with an embedded ELFbac policy
linked in. The same steps can be performed manually by crafting a linker script
which places separate policy states in separate page-aligned sections, enabling
the page fault handler to detect and handle accesses which should be denied by
policy or trigger a transition. The binary ELFbac policy itself is placed in a
special segment which is interpreted by the ELF binfmt parser inside of an
ELFbac-aware kernel, please refer to the generate_binary_policy function inside
of elfbac-ld.py and/or elfbac_parse_policy inside of kernel/elfbac.c to
understand the exact contents of a binary policy.

## Porting to New Architectures

The main addition which will need to occur to enable elfbac-ld to work on new
architectures is to create a new linker script template for the given
architecture. The default linker script can be dumped by running `ld --verbose`,
which can be placed in a moustache template file in the templates directory. The
parameters passed to the template system are defined in render_linker_script in
elfbac-ld.py. Once the new script template is created, it can be used by
specifying the name of the template to elfbac-ld.py with `--arch`.

## Porting to Other Linkers 

Some interest has been mentioned in enabling ELFbac to work with an LLVM-based
toolchain, this should not be an issue as in most toolchain setups clang will
utilize the system linker by default, which in most cases will be the GNU
linker. If lld is used, new support will need to be added as the required
support to interpret the linker scripts generated by this tool does not
currently exist in lld. If this machinery were added at a later date to lld, the
modifications should be minimal due to their desired compatiblity with the GNU
linker. Alternatively, if a scheme to create the requried section layout given
the constraints of the lld linker script interpreter is devised, a new linker
script template could be created which does just that.

A similar situation exists with the gold linker, which has a limited linker
script interpreter which has issues when the default SECTION alignment is
modified. It is possible that the linker scripts generated by the tool will
operate properly, but it is likely that modifications will be necessary in order
to get gold to generate the correct section layout.

